<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>Esc√°ner QR ‚Äî Minimal con tooltip (jQuery)</title>

<!-- jQuery para manejo de DOM/eventos -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<!-- Librer√≠a del lector QR -->
<script src="https://unpkg.com/html5-qrcode"></script>

<style>
  :root { color-scheme: dark light; }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body { margin:0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#0b1220; color:#e5e7eb; }
  header { padding:12px 16px; border-bottom:1px solid #1f2937; background:#0f172a; }
  main { padding:16px; display:grid; gap:12px; max-width:760px; margin:auto; }

  /* === Visor cuadrado === */
  .reader-wrap {
    position: relative; width: 100%; max-width: 520px; margin: auto;
    touch-action: pan-y; border-radius: 12px; overflow: hidden; background: #000;
    aspect-ratio: 1 / 1;
  }
  #reader, #reader > div, #reader video, #reader canvas {
    position: absolute; inset: 0; width: 100% !important; height: 100% !important;
  }
  #reader video { object-fit: cover; display:block; background:#000; }

  /* === Overlay de foco (anillo) === */
  #focusOverlay { position:absolute; inset:0; pointer-events:none; overflow:hidden; z-index:3; }
  .focus-ring {
    position:absolute; width:40px; height:40px; border-radius:50%;
    border:2px solid rgba(125,211,252,.95); box-shadow:0 0 12px rgba(125,211,252,.55);
    transform: translateZ(0) scale(.7); opacity: 0;
  }
  .focus-ring.anim-in { animation: focus-pop 180ms cubic-bezier(.2,.8,.2,1) forwards; }
  @keyframes focus-pop { 0%{transform:scale(.7);opacity:0} 60%{transform:scale(1.08);opacity:1} 100%{transform:scale(1);opacity:1} }
  .focus-ring.ok { border-color:#10b981; animation: focus-pop 180ms cubic-bezier(.2,.8,.2,1) forwards, focus-pulse 620ms ease-out 1 80ms; }
  @keyframes focus-pulse { 0%{transform:scale(1)} 50%{transform:scale(1.06)} 100%{transform:scale(1)} }
  .focus-ring.fail { border-color:#ef4444; animation: focus-pop 160ms ease-out forwards, focus-shake .28s linear 1 60ms; }
  @keyframes focus-shake { 0%{ transform: translateX(0) } 20%{ transform: translateX(-4px)} 40%{ transform: translateX(4px)} 60%{ transform: translateX(-3px)} 80%{ transform: translateX(3px)} 100%{ transform: translateX(0)} }
  .focus-ring.fade-out { animation: focus-fade .18s ease-out forwards; }
  @keyframes focus-fade { to { opacity: 0; transform: scale(.92) } }

  /* === FAB que abre controles === */
  .fab {
    position: fixed; right: 18px; bottom: 18px; z-index: 30;
    width: 62px; height: 62px; border-radius: 50%;
    background: radial-gradient(100% 100% at 30% 20%, #3b82f6, #0ea5e9 70%);
    color: #fff; display: grid; place-items: center; font-size: 28px;
    box-shadow: 0 12px 28px rgba(0,0,0,.35), inset 0 0 10px rgba(255,255,255,.18);
    border: 1px solid rgba(255,255,255,.25);
    cursor: pointer;
    transform: scale(1); opacity: 1; transition: transform .18s ease, opacity .18s ease;
  }
  .fab.hide { transform: scale(.85); opacity: 0; pointer-events: none; }

  /* === Panel de controles === */
  .controls-shell { position: fixed; left:0; right:0; bottom:0; z-index: 40; pointer-events: none; }
  .controls-shell .controls {
    margin: 0 auto 12px auto; width: min(680px, 96vw);
    background: rgba(10,14,22,.9);
    backdrop-filter: blur(14px);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,.45);
    padding: 12px 14px;
    transform: translateY(18px); opacity: 0; transition: transform .25s cubic-bezier(.2,.7,.2,1), opacity .25s ease;
  }
  .controls-shell.open { pointer-events: auto; }
  .controls-shell.open .controls { transform: translateY(0); opacity: 1; }

  /* === Zoom: fila con min | slider | max === */
  .zoom-row { display:grid; grid-template-columns: auto 1fr auto; align-items:center; gap:10px; }
  .zoom-side { font-size:.95rem; opacity:.9; font-variant-numeric: tabular-nums; min-width:3ch; text-align:center; }

  .zoom-track-wrap { position: relative; padding: 20px 4px 10px; /* espacio para el tooltip */ }
  .zoom-track { -webkit-appearance:none; appearance:none; width:100%; height: 12px; background: transparent; }
  .zoom-track::-webkit-slider-runnable-track { height: 12px; border-radius:999px; background: rgba(255,255,255,.18); }
  .zoom-track::-moz-range-track { height: 12px; border-radius:999px; background: rgba(255,255,255,.18); }
  .zoom-track::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none;
    width: 28px; height: 28px; border-radius:50%;
    background: #e5e7eb;
    box-shadow: 0 4px 12px rgba(0,0,0,.35);
    margin-top: -8px; cursor: pointer;
  }
  .zoom-track::-moz-range-thumb{
    width: 28px; height: 28px; border-radius:50%;
    background: #e5e7eb;
    box-shadow: 0 4px 12px rgba(0,0,0,.35);
    cursor: pointer;
  }

  /* Tooltip fijo (siempre visible) con valor actual */
  .zoom-tip{
    position:absolute; top: 0; transform: translate(-50%, -30%);
    min-width: 48px; height: 24px; padding:0 8px; border-radius:8px;
    display:flex; align-items:center; justify-content:center;
    font-weight:700; font-size:.9rem; font-variant-numeric: tabular-nums;
    background: rgba(255,255,255,.85); color:#0b1220;
    box-shadow: 0 2px 10px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.25);
    pointer-events:none; user-select:none;
    white-space:nowrap;
  }

  /* === Buttons === */
  .controls-row { display:flex; align-items:center; gap:10px; justify-content:space-between; margin-top:12px; }
  .ctrl-btn{
    flex:0 0 auto; min-width:56px; height:48px; border-radius:12px;
    background:#0f172a; color:#e5e7eb; border:1px solid rgba(255,255,255,.15);
    display:flex; align-items:center; justify-content:center; font-size:22px; cursor:pointer;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease, opacity .12s;
  }
  .ctrl-btn:active { transform: translateY(1px); }
  .ctrl-btn:disabled{ opacity:.5; cursor:not-allowed }
  .ctrl-btn.primary{ background:#1d283a; border-color:#93c5fd; box-shadow: 0 0 0 2px rgba(59,130,246,.2) inset; }

  .ok{ color:#10b981 } .warn{ color:#f59e0b } .err{ color:#ef4444 }
  .meta{ font-size:.85rem; opacity:.85 }
  .result{ font-weight:600 }
</style>
</head>
<body>
  <header><strong>Esc√°ner QR ‚Äî Minimal con tooltip (jQuery)</strong></header>

  <main>
    <!-- Visor + overlay para anillos de enfoque -->
    <div class="reader-wrap" id="tapZone">
      <div id="reader"></div>
      <div id="focusOverlay"></div>
    </div>

    <div class="meta">
      ‚Ä¢ Min y Max a los **lados** del slider. Tooltip **siempre visible** con el **zoom actual**.<br>
      ‚Ä¢ Tap-to-focus, pinch-to-zoom, linterna, persistencia y auto-pause/resume.
    </div>
    <div id="lastResult" class="result ok"></div>
    <div id="status" class="meta"></div>
  </main>

  <!-- FAB -->
  <button id="fab" class="fab" title="Controles">‚öôÔ∏è</button>

  <!-- Panel de controles -->
  <div id="controlsShell" class="controls-shell" aria-live="polite">
    <div class="controls" role="group" aria-label="Controles del lector">

      <!-- Fila: [min] [slider+tooltip] [max] -->
      <div class="zoom-row">
        <span id="zoomMinLabel" class="zoom-side">1</span>

        <div id="zoomTrackWrap" class="zoom-track-wrap">
          <input id="zoomTrack" class="zoom-track" type="range" min="1" max="1" step="0.01" value="1" />
          <div id="zoomTip" class="zoom-tip">‚Äî</div>
        </div>

        <span id="zoomMaxLabel" class="zoom-side">1</span>
      </div>

      <div class="controls-row">
        <button id="torchBtn"   class="ctrl-btn" title="Linterna" aria-pressed="false" disabled>üî¶</button>
        <div class="ctrl-spacer"></div>
        <button id="resetZoomBtn" class="ctrl-btn" title="Restablecer zoom" disabled>‚Ü©Ô∏è</button>
        <button id="playPauseBtn" class="ctrl-btn primary" title="Iniciar / Pausar / Reanudar">‚ñ∂Ô∏è</button>
        <button id="stopBtn"      class="ctrl-btn" title="Detener" disabled>‚èπÔ∏è</button>
        <div class="ctrl-spacer"></div>
        <button id="closeCtrlsBtn" class="ctrl-btn" title="Cerrar controles">‚úñÔ∏è</button>
      </div>
    </div>
  </div>

<script>
/* =====================================================================
   Esc√°ner QR minimal con slider + tooltip (jQuery)
   ===================================================================== */

  /* ---------------- Config y estado global ---------------- */
  const CONFIG_BASE = {
    fps: 15,
    qrbox: { width: 200, height: 200 },
    aspectRatio: 1.0,
    rememberLastUsedCamera: true,
    videoConstraints: { facingMode: { ideal: "environment" }, width:{ideal:1920}, height:{ideal:1080} }
  };
  const LSK = { ZOOM:'qr_zoom_value', TORCH:'qr_torch_on' };

  const html5QrCode = new Html5Qrcode("reader");

  // Refs jQuery
  const $tapZone       = $('#tapZone');
  const $overlay       = $('#focusOverlay');
  const $statusEl      = $('#status');
  const $lastResult    = $('#lastResult');
  const $fab           = $('#fab');
  const $controlsShell = $('#controlsShell');

  const $zoomWrap      = $('#zoomTrackWrap');
  const $zoomTrack     = $('#zoomTrack');
  const $zoomTip       = $('#zoomTip');
  const $zoomMinLabel  = $('#zoomMinLabel');
  const $zoomMaxLabel  = $('#zoomMaxLabel');

  const $torchBtn      = $('#torchBtn');
  const $resetZoomBtn  = $('#resetZoomBtn');
  const $playPauseBtn  = $('#playPauseBtn');
  const $stopBtn       = $('#stopBtn');
  const $closeCtrlsBtn = $('#closeCtrlsBtn');

  // Estado
  let mediaStream=null, videoTrack=null, zoomCaps=null;
  let defaultZoom=1, currentZoom=null;
  let starting=false, firstDecodeDone=false;
  let state='idle', autoResume=false;
  let pinchActive=false, pinchStartDist=0, pinchStartZoom=1;
  let desiredTorchOn = (localStorage.getItem(LSK.TORCH) === '1');
  let tapStart=null;

  const getVideoEl = function(){ return document.querySelector('#reader video'); };
  const setStatus  = function(t,c){ if(c===undefined){c='';} $statusEl.text(t).attr('class', 'meta '+c); };
  const isLikelyUrl= function(s){ return /^https?:\/\/|^[\w-]+\.[\w.-]+(\/|$)/i.test(s); };
  const clamp      = function(n,min,max){ return Math.min(max,Math.max(min,n)); };
  const fmtExact   = function(z,dec){ if(dec===undefined){dec=2;} var p=Math.pow(10,dec); return (Math.round(z*p)/p).toString().replace('.',','); };
  const fmtZoom    = function(z){ return fmtExact(z) + '√ó'; };
  function haptic(ms){ if(ms===undefined){ms=16;} try{ if(navigator.vibrate){ navigator.vibrate(ms); } }catch(e){} }

  /* ---------------- Tooltip: actualizar texto y posici√≥n ---------------- */
  function updateTip(val){
    // Texto
    if(Number.isFinite(val)){ $zoomTip.text(fmtZoom(val)); } else { $zoomTip.text('‚Äî'); }

    // Posici√≥n centrada sobre el porcentaje del track
    if(!$zoomTrack.length || !$zoomWrap.length){ return; }
    var trackRect = $zoomTrack[0].getBoundingClientRect();
    var wrapRect  = $zoomWrap[0].getBoundingClientRect();
    var min = parseFloat($zoomTrack.attr('min'));
    var max = parseFloat($zoomTrack.attr('max'));
    var pct = (max>min) ? ((val - min) / (max - min)) : 0;

    var x = (trackRect.left - wrapRect.left) + (pct * trackRect.width);
    var xClamped = Math.min(wrapRect.width - 8, Math.max(8, x));
    $zoomTip.css('left', xClamped + 'px');
  }

  function setZoomLabelsToCaps(){
    if(!zoomCaps){ $zoomMinLabel.text('‚Äî'); $zoomMaxLabel.text('‚Äî'); return; }
    $zoomMinLabel.text(fmtExact(zoomCaps.min));
    $zoomMaxLabel.text(fmtExact(zoomCaps.max));
  }

  /* ---------------- Focus ring (feedback del tap) ---------------- */
  function clearFocusRings(immediate){
    if(immediate===undefined){immediate=true;}
    var $rings = $overlay.find('.focus-ring');
    if(immediate){ $rings.remove(); }
    else{ $rings.addClass('fade-out'); setTimeout(function(){ $rings.remove(); }, 200); }
  }
  function spawnFocusRing(px,py){
    var $r=$('<div class="focus-ring"></div>').css({left:(px-20)+'px', top:(py-20)+'px'});
    $overlay.append($r);
    requestAnimationFrame(function(){ $r.addClass('anim-in'); });
    var t1=setTimeout(function(){ $r.addClass('fade-out'); }, 900);
    var t2=setTimeout(function(){ $r.remove(); }, 1200);
    $r.data('_timeouts',[t1,t2]);
    return $r;
  }
  function markRing($r, kind){
    if(!$r||!$r.length) return;
    ($r.data('_timeouts')||[]).forEach(function(t){ clearTimeout(t); });
    $r.removeClass('fade-out').addClass(kind);
    setTimeout(function(){ $r.addClass('fade-out'); }, (kind==='ok')?650:380);
    setTimeout(function(){ $r.remove(); }, (kind==='ok')?880:600);
  }

  /* ---------------- QRBOX proporcional ---------------- */
  function computeQrbox(){
    var side = $tapZone[0].getBoundingClientRect().width || 320;
    var box = Math.round(Math.min(side * 0.60, 320));
    return { width: box, height: box };
  }

  /* ---------------- Ciclo del lector ---------------- */
  async function startScanner(){
    if(starting || state!=='idle') return;
    starting=true; firstDecodeDone=false; setStatus('Iniciando‚Ä¶','warn'); $lastResult.text('');
    var cfg={...CONFIG_BASE, qrbox:computeQrbox()};

    try{
      await html5QrCode.start({ facingMode:"environment" }, cfg, onScanSuccess, function(){});
      var v=getVideoEl(); mediaStream=v && v.srcObject ? v.srcObject : null; videoTrack=mediaStream ? mediaStream.getVideoTracks()[0] : null;

      var caps={};
      try{ caps = (videoTrack && videoTrack.getCapabilities) ? videoTrack.getCapabilities() : {}; }catch(e){ caps={}; }

      // Torch
      if (caps.torch) { $torchBtn.prop('disabled',false); await ensureTorchState(desiredTorchOn); }
      else { $torchBtn.prop('disabled',true); setTorchUI(false); }

      // Zoom nativo
      if(caps.zoom){
        zoomCaps = { min: (caps.zoom.min!=null?caps.zoom.min:1), max: (caps.zoom.max!=null?caps.zoom.max:1), step: (caps.zoom.step!=null?caps.zoom.step:0.01) };
        var s=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
        var saved=parseFloat(localStorage.getItem(LSK.ZOOM));
        var zInit = (!isNaN(saved) && saved>=zoomCaps.min && saved<=zoomCaps.max) ? saved : ( (s.zoom!=null)? s.zoom : zoomCaps.min );
        defaultZoom = clamp( (s.zoom!=null)? s.zoom : zoomCaps.min, zoomCaps.min, zoomCaps.max );
        currentZoom = zInit;

        setupZoomTrack();
        await applyZoom(zInit);
        setZoomLabelsToCaps();
        updateResetZoomEnabled();
        updateTip(currentZoom);
      } else {
        zoomCaps=null; defaultZoom=1; currentZoom=null;
        setupZoomTrack();
        updateResetZoomEnabled();
        setZoomLabelsToCaps();
        setZoomTrackEnabled(false, 'El zoom no est√° soportado por esta c√°mara');
        updateTip(NaN);
      }

      $stopBtn.prop('disabled', false);
      setState('running'); setStatus('Escaneando','ok');
      setZoomTrackEnabled(!!zoomCaps);
    }catch(e){
      setStatus(describeStartError(e),'err');
    }finally{
      starting=false;
    }
  }

  async function pauseScanner(){
    if(state!=='running') return;
    try{
      html5QrCode.pause(true);
      setState('paused'); setStatus('Pausado','warn');
      setZoomTrackEnabled(false);
      $torchBtn.prop('disabled',true);
    }catch(e){}
  }

  async function resumeScanner(){
    if(state!=='paused') return;
    try{
      html5QrCode.resume();
      await syncTorchUIAfterResume();
      setState('running'); setStatus('Escaneando','ok');
      setZoomTrackEnabled(!!zoomCaps);
      var caps=(videoTrack && videoTrack.getCapabilities)? videoTrack.getCapabilities() : {};
      $torchBtn.prop('disabled', !caps.torch);
      updateTip(currentZoom!=null ? currentZoom : parseFloat($zoomTrack.val()) || NaN);
    }catch(e){}
  }

  async function stopScanner(){
    if(state==='idle') return;
    try{ await html5QrCode.stop(); await html5QrCode.clear(); }catch(e){}
    mediaStream=null; videoTrack=null; zoomCaps=null; currentZoom=null;
    $stopBtn.prop('disabled', true);
    autoResume=false; setState('idle'); setStatus('Detenido');
    clearFocusRings(true);
    setZoomTrackEnabled(false);
    $torchBtn.prop('disabled', true);
    updateTip(NaN);
  }

  function setState(next){
    state=next;
    if(state==='idle'){ $playPauseBtn.text('‚ñ∂Ô∏è').attr('title','Iniciar'); }
    else if(state==='running'){ $playPauseBtn.text('‚è∏Ô∏è').attr('title','Pausar'); }
    else if(state==='paused'){ $playPauseBtn.text('‚ñ∂Ô∏è').attr('title','Reanudar'); }
  }

  /* ---------------- Lectura exitosa ---------------- */
  async function onScanSuccess(text){
    if(firstDecodeDone) return;
    firstDecodeDone=true;
    try{ if(navigator.vibrate){ navigator.vibrate(40); } }catch(e){}
    $lastResult.text('Detectado: '+text);
    await stopScanner();
    if(isLikelyUrl(text)){
      var url = /^https?:\/\//i.test(text) ? text : ('https://'+text);
      location.href=url;
    } else {
      alert('C√≥digo detectado:\n'+text);
    }
  }

  /* ---------------- Tap-to-focus ---------------- */
  $tapZone.on('pointerdown', function(e){
    var ev=e.originalEvent;
    if (state!=='running' || !ev || ev.pointerType!=='touch') return;
    tapStart={x:e.clientX,y:e.clientY,t:performance.now()};
  });
  $tapZone.on('pointerup', async function(e){
    if (state!=='running' || !tapStart) return;
    var dx=e.clientX-tapStart.x, dy=e.clientY-tapStart.y, dt=performance.now()-tapStart.t;
    tapStart=null; if(Math.hypot(dx,dy)>10 || dt>300) return;

    clearFocusRings(false);
    var rect=$tapZone[0].getBoundingClientRect();
    var px=e.clientX-rect.left, py=e.clientY-rect.top;
    var $R=spawnFocusRing(px,py);

    if(!videoTrack){ markRing($R,'fail'); return; }
    var caps=(videoTrack && videoTrack.getCapabilities)? videoTrack.getCapabilities() : {};

    if(caps.pointsOfInterest){
      var vrect=getVideoEl().getBoundingClientRect();
      var x=(e.clientX-vrect.left)/vrect.width, y=(e.clientY-vrect.top)/vrect.height;
      try{
        await videoTrack.applyConstraints({ advanced:[{ focusMode:'single-shot', pointsOfInterest:[{x:x,y:y}] }] });
        markRing($R,'ok'); return;
      }catch(err1){
        try{
          await videoTrack.applyConstraints({ advanced:[{ focusMode:'manual', pointsOfInterest:[{x:x,y:y}] }] });
          markRing($R,'ok'); return;
        }catch(err2){}
      }
    }
    if(zoomCaps){
      try{
        var s=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
        var cur=(s.zoom!=null)? s.zoom : zoomCaps.min;
        var bump=clamp(cur+(zoomCaps.step||0.1), zoomCaps.min, zoomCaps.max);
        await videoTrack.applyConstraints({advanced:[{zoom:bump}]}); await new Promise(function(r){ setTimeout(r,120); });
        await videoTrack.applyConstraints({advanced:[{zoom:cur}]});
        markRing($R,'ok'); return;
      }catch(err3){}
    }
    try{ await quickRefocus(); markRing($R,'ok'); }catch(err4){ markRing($R,'fail'); }
  });
  $tapZone.on('pointercancel', function(){ tapStart=null; });

  /* ---------------- Pinch-to-zoom ---------------- */
  $tapZone.on('touchstart', function(e){
    var t=e.originalEvent;
    if(!t || !t.touches) return;
    if(t.touches.length===2){
      if(!zoomCaps){ return; }
      pinchActive=true; t.preventDefault();
      var a=t.touches[0], b=t.touches[1];
      pinchStartDist=Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      var s=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
      var saved=parseFloat(localStorage.getItem(LSK.ZOOM));
      var base = (s.zoom!=null)? s.zoom : (currentZoom!=null? currentZoom : (!isNaN(saved)? saved : 1));
      pinchStartZoom=clamp(base, zoomCaps.min, zoomCaps.max);
    }
  });
  $tapZone.on('touchmove', async function(e){
    if(!pinchActive) return;
    var t=e.originalEvent;
    if(!t || !t.touches){ onPinchEnd(); return; }
    if(t.touches.length!==2){ onPinchEnd(); return; }
    t.preventDefault();
    var a=t.touches[0], b=t.touches[1];
    var curDist=Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
    var scale=curDist/(pinchStartDist||1);
    var target=clamp(pinchStartZoom*scale, zoomCaps.min, zoomCaps.max);
    await applyZoom(target); updateTip(currentZoom);
  });
  $tapZone.on('touchend touchcancel', function(){ if(pinchActive) onPinchEnd(); });
  function onPinchEnd(){
    pinchActive=false;
    if(zoomCaps && currentZoom!=null){
      try{ localStorage.setItem(LSK.ZOOM, currentZoom.toString()); }catch(e){}
      updateResetZoomEnabled();
    }
  }

  /* ---------------- Zoom / Slider / Reset ---------------- */
  async function applyZoom(val){
    if(!videoTrack||!zoomCaps) return;
    var z=parseFloat(val);
    if(!isFinite(z)){ z=zoomCaps.min; }
    z=clamp(z, zoomCaps.min, zoomCaps.max);
    try{
      await videoTrack.applyConstraints({advanced:[{zoom:z}]});
      currentZoom = z;
      updateResetZoomEnabled();
      syncZoomTrackUI();
      updateTip(currentZoom);
    }catch(e){}
  }
  function updateResetZoomEnabled(){
    if(!zoomCaps || currentZoom==null){ $resetZoomBtn.prop('disabled',true); return; }
    var isDefault = Math.abs(currentZoom - defaultZoom) <= 0.001;
    $resetZoomBtn.prop('disabled', isDefault);
  }
  function setupZoomTrack(){
    var min=1, max=1, step=0.01, val=1;
    if(zoomCaps){
      min  = (zoomCaps.min!=null)? zoomCaps.min : 1;
      max  = (zoomCaps.max!=null)? zoomCaps.max : 1;
      step = (zoomCaps.step!=null)? zoomCaps.step : 0.01;
      val  = (currentZoom!=null)? currentZoom : min;
      $zoomTrack.prop('disabled', false).removeAttr('title');
    } else {
      $zoomTrack.prop('disabled', true).attr('title','El zoom no est√° soportado por esta c√°mara');
    }
    $zoomTrack.attr('min', String(min));
    $zoomTrack.attr('max', String(max));
    $zoomTrack.attr('step', String(step));
    $zoomTrack.val(String(val));
  }
  function syncZoomTrackUI(){ if(currentZoom!=null){ $zoomTrack.val(String(currentZoom)); } }
  function setZoomTrackEnabled(enabled, tooltip){
    if(tooltip===undefined){ tooltip=''; }
    var allow = !!enabled && !!zoomCaps;
    $zoomTrack.prop('disabled', !allow).css('opacity', allow?1:.6);
    if(!allow){ $zoomTrack.attr('title', tooltip || 'Control deshabilitado'); } else { $zoomTrack.removeAttr('title'); }
  }

  // Arrastre del slider ‚Üí aplica zoom + actualiza tooltip
  $zoomTrack.on('input', async function(){
    if ($zoomTrack.prop('disabled')) return;
    var z = parseFloat($zoomTrack.val());
    await applyZoom(z);
  });
  // Al soltar ‚Üí persistir
  function persistZoom(){
    if(!zoomCaps || currentZoom==null) return;
    try{ localStorage.setItem(LSK.ZOOM, currentZoom.toString()); }catch(e){}
    updateResetZoomEnabled();
  }
  $zoomTrack.on('change pointerup touchend mouseup', persistZoom);

  /* ---------------- Torch ---------------- */
  function setTorchUI(on){
    $torchBtn.toggleClass('primary', !!on).attr('aria-pressed', on ? 'true' : 'false');
  }
  async function ensureTorchState(on){
    var desired = !!on;
    try{ localStorage.setItem(LSK.TORCH, desired ? '1':'0'); }catch(e){}
    desiredTorchOn = desired;
    var caps=(videoTrack && videoTrack.getCapabilities)? videoTrack.getCapabilities() : {};
    if (videoTrack && caps.torch) {
      try{
        var s=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
        if (!!s.torch !== desiredTorchOn) {
          await videoTrack.applyConstraints({ advanced:[{ torch: desiredTorchOn }] });
        }
      }catch(e){}
    }
    setTorchUI(desiredTorchOn);
  }
  async function syncTorchUIAfterResume(){
    var caps=(videoTrack && videoTrack.getCapabilities)? videoTrack.getCapabilities() : {};
    if (!videoTrack || !caps.torch) { setTorchUI(false); return; }
    try{
      var s=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
      if (!!s.torch !== desiredTorchOn) {
        await videoTrack.applyConstraints({ advanced:[{ torch: desiredTorchOn }] });
      }
      setTorchUI(desiredTorchOn);
    }catch(e){
      try{
        var s2=(videoTrack && videoTrack.getSettings)? videoTrack.getSettings() : {};
        setTorchUI(!!s2.torch);
      }catch(e2){
        setTorchUI(false);
      }
    }
  }
  $torchBtn.on('click', async function(){
    haptic(16);
    if ($torchBtn.prop('disabled')) return;
    await ensureTorchState(!$torchBtn.hasClass('primary'));
  });

  /* ---------------- Play/Pause/Stop y Reset ---------------- */
  $playPauseBtn.on('click', async function(){
    haptic(12);
    if(state==='idle')        { await startScanner(); }
    else if(state==='running'){ await pauseScanner(); }
    else if(state==='paused') { await resumeScanner(); }
  });
  $stopBtn.on('click', async function(){ haptic(20); await stopScanner(); });
  $resetZoomBtn.on('click', async function(){
    haptic(12);
    if(!zoomCaps || $resetZoomBtn.prop('disabled')) return;
    var target=defaultZoom;
    await applyZoom(target);
    try{ localStorage.setItem(LSK.ZOOM, String(target)); }catch(e){}
    updateResetZoomEnabled();
    syncZoomTrackUI();
  });

  /* ---------------- FAB y panel ---------------- */
  function openControls(){
    $controlsShell.addClass('open');
    $fab.addClass('hide');
    haptic(8);
    updateTip(currentZoom!=null ? currentZoom : (parseFloat($zoomTrack.val()) || NaN));
  }
  function closeControls(){
    $controlsShell.removeClass('open');
    $fab.removeClass('hide');
    haptic(8);
  }
  $fab.on('click', openControls);
  $closeCtrlsBtn.on('click', closeControls);

  /* ---------------- AutoPause / AutoResume ---------------- */
  $(document).on('visibilitychange', async function(){
    if (document.hidden) {
      if (state === 'running') { await pauseScanner(); autoResume = true; }
      else { autoResume = false; }
    } else {
      if (autoResume && state === 'paused') { await resumeScanner(); }
      autoResume = false;
    }
  });
  $(window).on('pagehide', async function(){ if (state === 'running') { await pauseScanner(); autoResume = true; } else { autoResume = false; } });
  $(window).on('pageshow', async function(){ if (autoResume && state === 'paused') { await resumeScanner(); } autoResume = false; });

  /* ---------------- Enfoque r√°pido (reinicio de stream) ---------------- */
  async function quickRefocus(){ if(!videoTrack) throw new Error('no track'); await stopScanner(); await startScanner(); }

  /* ---------------- Init ---------------- */
  (function init(){
    setStatus('Listo');
    setZoomTrackEnabled(false);
    setZoomLabelsToCaps();
    setTorchUI(desiredTorchOn);

    // Mantener tooltip bien posicionado si cambia el layout
    if($zoomWrap.length){
      var ro = new ResizeObserver(function(){
        var cur = (currentZoom!=null) ? currentZoom : (parseFloat($zoomTrack.val()) || NaN);
        updateTip(cur);
      });
      ro.observe($zoomWrap[0]);
    }
    $(window).on('resize scroll', function(){
      var cur = (currentZoom!=null) ? currentZoom : (parseFloat($zoomTrack.val()) || NaN);
      updateTip(cur);
    });

    // Permiso de c√°mara anticipado (mejor UX)
    navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" } }).catch(function(){});
  })();

  /* ---------------- Errores legibles ---------------- */
  function describeStartError(e){
    var name=(e && (e.name || (e.toString && e.toString()))) ? (e.name || e.toString()) : '';
    if(/NotAllowedError/i.test(name)) return 'Permiso de c√°mara denegado.';
    if(/NotFoundError|OverconstrainedError/i.test(name)) return 'No se encontr√≥ la c√°mara o no soporta las constraints.';
    if(/NotReadableError|TrackStartError/i.test(name)) return 'La c√°mara est√° en uso por otra app.';
    if(/SecurityError/i.test(name)) return 'Se requiere HTTPS para usar la c√°mara.';
    return 'Error al iniciar la c√°mara: ' + (e && e.message ? e.message : name);
  }
</script>
</body>
</html>
